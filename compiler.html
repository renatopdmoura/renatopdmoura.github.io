<!DOCTYPE html>	
<html>
<head>
	<title>ImCreate</title>
	<meta charset="UTF-8">
	<meta name="description" content="Referência">
	<meta name="keywords" content="Programação, C++, OpenGL">
	<meta name="author" content="Renato Moura">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- include css -->
	<link rel="stylesheet" href="css/common.css" type="text/css">
	<link rel="stylesheet" href="css/tutoriais.css" type="text/css">
	<!-- include javascript -->
	<script type="text/javascript" src="js/javascript.js"></script>
</head>
<body>
	<main id="main-container" class="row">
		<header id="main-header" class="col-s-12 col-t-12 col-d-12">
			<div id="main-title" class="col-s-12 col-t-5 col-d-5">
				<h1>ImCreate</h1>
			</div>
			<nav class="col-s-12 col-t-7 col-d-7 row">
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="index.html" class="link-menu">Apresentação</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="tutoriais.html" class="link-menu">Tutoriais</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="reference.html" class="link-menu">Referência</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="https://github.com/renatopdmoura/pura-project.git" target="_blank" accesskey="t" class="link-menu">Download</a></span>
			</nav>
		</header>
		<section class="col-s-12 col-t-12 col-d-12 content">
			<h2>Conceitos de Compilação</h2>
			<p>Antes de começarmos a desenvolver projetos em C++ é de suma importância aprender sobre o trabalho que os compiladores realizam para gerar um arquivo executável.</p>
			<p>Um compilador é um software capaz de transformar código fonte de linguagem de alto nível em código de linguagem de baixo nível chamado de <var>código binário</var>(como código de máquina e assembly). O código então gerado é voltado ao uso em um determinado tipo de arquitetura de processamento(CISC ou RISC). Um compilador possui um pipeline de estágios, onde a saída de um estágio anterior é a entrada para o próximo estágio.</p>
			<p>A compilação pode ser dividida em duas fases, sendo elas:</p>
			<h3>Análise</h3>
				<p>Análise léxica: o código fonte original é transformado em um fluxo de caracteres que será convertido em lexemas(a menor unidade simbólica de uma linguagem) conhecidos como <var>tokens</var>. A tradução para tokens depende da linguagem de alto nível utilizada, por exemplo em C++:</p>
			<code>
				<div class="code-snippet">
					unsigned int value = 8;<br>
					// unsigned int é um token "keyword"<br>
					// value é um token "identifier"<br>
					// = é um token "operator"<br>
					// 8 é um token "constant"<br>
					// ; é um token "symbol"<br>
				</div>
			</code>
			<p>Análise sintática: nessa etapa, é feita a busca por tokens inválidos que o analisador léxico tenha julgado como corretos. O analisador sintático busca por símbolos não terminais(como variáveis), símbolos terminais(determinados pela linguagem), regras combinatórias para terminais e não terminais gerarem <var>strings</var> e símbolos de partida.</p>
			<p>Análise semântica: essa análise verifica se há coerência linguística entre os tokens definidos, se váriaveis foram declaradas e inicializadas.</p>
			<h3>Síntese</h3>
			<p>Código intermediário: após as traduções das etapas de análise, um código independente de máquina é gerado para então o compliador gerar um código especifico para determianda arquitetura. Essa fase de gerar código intermediário aumenta a portabilidade e seguementação de código pois torna menos complexo a conversão para linguagem de máquina.</p>
			<p>Otimização de código independente de máquina: nesse ponto, o compilador toma liberdade em realizar ajustes para reescrever o código de tal modo que diminua a carga em processamento e gerenciamento de memória.</p>
			<p>A etapa final pode ser descrita como a geração do código em si em linguagem de baixo nível, o qual carrega o exato significado do código fonte original e otimizado de acordo.</p>
			<p>A saída final direta de um compilador é designada como <var>arquivo de objeto</var> sendo o respectivo código binário do código fonte de alto nível. Arquivos objeto são conhecidos por ter extensão .o(GCC) ou .obj(MSVC), e por vezes, um conjunto de arquivos de objeto podem ser armazenados em um mesmo lote de arquivo afim de permitir otimizações no momento da vinculação do código binário. Esse conjunto de arquivos de objetos pode ser referido como uma <var>biblioteca</var> e são comumente arquivados(analogamente a arquivos zip) sob a extensão de arquivo .a(GCC) ou .lib(MSVC) afim de serem usados no processo de <var>vinculação</var>. A etapa de vinculação é tida, de forma resumida, como o momento final antes da geração de um executavel. O vinculador recebe arquivos .o/.obj, .a/.lib .so/.dll e realiza um processo de linkedição determinada pelos sinalizadores definidos pelo programador afim de gerar um arquivo de objeto de saída que torna-se-á o executavel final.</p>
				
			<p>Com essa introdução, temos um breve, mas suficiente entendimento para aprender a compilar nossos projetos. Um bom primeiro passo é começar explanando sobre a geração de bibliotecas.</p>

			<h3>Indo por partes</h3>
			<p>Quando estamos trabalhando em um projeto, não são poucas as séries de funções que estão disponíveis para nosso uso. Em diferentes arquivos estas funções podem ser acessadas de modo que exista apenas um lugar de declaração e implementação para elas. Isso só é possível pela existência de bibliotecas(como um conjunto de funções dispostos a resolver uma determinada área de problemas), e essas bibliotecas podem ser ditas como: estáticas ou dinâmicas.</p>
			<h3>Bibliotecas estáticas</h3>
			<p> As bibliotecas estáticas tem a extensão .a ou .lib(essa variação depende do compilador usado para gerá-las). Bibliotecas estáticas são feitas para serem usadas em qualquer programa apenas com a diretiva de inclusão "#include" adicionando o caminho dos arquivos de cabeçalho da biblioteca a serem acessados após serem devidamente vinculadas. O que é singular sobre uma biblioteca estática é que, para cada arquivo em seu projeto que a inclua, uma cópia em tempo de compilação dos recursos da biblioteca estática para o escopo do arquivo que a inclui será gerada. Isso tem por efeito, que uma vez criado um executável, as funções chamadas da biblioteca farão parte do contéudo do executável de modo que se possíveis atualizações futuras da biblioteca forem necessárias, deve-se recompilar todo o código fonte.</p>
			<p>A vantagem é na garantia de não corrupção dos arquivos como ocorre com as bibliotecas dinâmicas(uma biblioteca estática compilada ao código fonte só para se o executavél parar), além de suas funções serem mais rápidas de acessar, pois a busca pelos protótipos é realizada no escopo do arquivo em contrapartida as bibliotecas dinâmicas, as quais funcioanam como recurso externo.</p>
			
			<h3>Bibliotecas dinâmicas</h3>
			<p>As bibliotecas dinâmicas são normalmente referidas pela extensão .dll(MSVC) e têm o potêncial de serem economicas. Bibliotecas dinâmicas diferentemente das estáticas não são anexadas ao escopo dos arquivos que fazem chamadas as suas funções, pelo contrário, o programa gera apenas uma cópia em tempo de compilação de seus recursos. Como mencionado anteriormente, elas atuam como um meio externo de modo que quando as associamos aos nossos projetos, chamadas as suas funções demandariam um tempo extra para desviar o fluxo de leitura atual para fora do executável solicitando o uso de determinadas funções. O ganho de uma biblioteca dinâmica está em sua portabilidade. Usar bibliotecas dinâmicas reduz o peso do arquivo final, já que não serão feitas cópias para cada arquivo que usa seus recursos, e, do ponto de vista da eficiência, caso novas alterações sejam necessárias para a biblioteca, desde que o fluxo de trabalho não mude não há necessidade de recompilar todo código fonte do seu projeto e sim apenas substiruir a <var>dll</var> no diretório de origem.</p>
			<p>Bibliotecas dinâmicas são também compartilhadas. Se você for até o diretório system32, verá muitas <var>dlls</var>, seria impressionante dizer que diferentes programas que usamos associam-se a uma mesma <var>dll</var> paralelamente?</p>

			<p>A conclusão sobre qual tipo de biblioteca usar depende em si do modo que ela será distribuída. Caso seja um recurso com baixa probalidade de ser mutável e focado em atender tarefas específicas de uma determinada aplicação, bibliotecas estáticas são uma boa escolha. Bibliotecas dinâmicas funcionam no outro lado da moeda. No fim, provavelmente você irá usar um misto em seus projetos(principalmente porque fazemos uso de bibliotecas desenvolvidas por terceiros), e (quase)sempre será uma questão de análise do seu projeto e o quanto ele pode ser reaproveitado por futuros projetos pesando também entre eficiência de espaço(bibliotecas dinâmicas) e eficiência de processamento(bibliotecas estáticas).</p>

			<h2>Resumindo</h2>
			<div class="card">
				<h3>Bibliotecas estáticas</h3>
				<P>Cada arquivo que as inclui fará uma cópia de suas funções/dados para o escopo do arquivo em tempo de compilação.</P>
				<p>Uma vez gerado o executável, as funções/dados da biblioteca estática só podem ser atualizados por recompilação.</p>
				<p>Bibliotecas estáticas não corrompem(pois estão atreladas ao binário do executavel).</p>
				<p>São rápidas de acessar(pois existem no escopo do arquivo que as inclui permitindo otimizações de chamada se possível).</p>
				<p>Enquanto salvam processamento, consomem espaço.</p>
			</div>
			<div class="card">
				<h3>Bibliotecas Dinâmicas</h3>
				<p>As funções/dados de uma biblioteca dinâmica existem em um arquivo separado ao executável que as usa. Assim, múltiplos arquivos em um executável acessam uma única cópia das funções/dados determinada em tempo de compilação.</p>
				<p>Bibliotecas dinâmicas podem ser atualizadas sem a necessidade de recompilação.</p>
				<p>São econômicas, pois um único arquivo é usado por toda aplicação, contudo, perdem em desempenho uma vez que é preciso desviar o fluxo de execução para um arquivo externo durante as chamadas à funções da biblioteca.</p>
				<p>São sucetiveis a corrupção de arquivos.</p>
				<p>Uma mesma dll(biblioteca dinâmica) pode ser usada paralelamente por múltiplos programas.</p>
			</div>
			
			<h2>Praticando</h2>
			<p>Estamos preparados para ter alguma prática. Vamos começar gerando bibliotecas estáticas usando o compilador da Microsoft(MSVC). Note: executáveis gerados por diferentes compiladores deverão smepre funcionar da mesma forma. Por fim, vamos também criar uma biblioteca dinâmica como exemplo.</p>

			<h3>Usando o MSVC</h3>
			<p>O MSVC é um compilador como ja mencionado pertencente a Microsoft. Ele costuma acompanhar a IDE do Visual Studio. Você pode fazer o download da IDE <a href="https://visualstudio.microsoft.com/pt-br/downloads/">aqui</a>.</p>
			<p>Após instalar a IDE, navegue até encontrar a seção do Visual Studio, encontre sua pasta então escolha entre x64 Native Tools Command Prompt for VS 2019/x86 Native Tools Command Prompt for VS 2019 dependendo do seu sistema operacional(64 ou 32 bits respectivamente).</p>
			<p>Iremos criar um simples programa para realizar cálculos de operações básicas com inteiros afim de experimentar os compiladores escolhidos. O código fonte será este:</p>
			<code>
				<div class="code-snippet">
					#include &lt;iostream&gt;<br>
					<br>
					int sum(int a, int b){<br>
						<div class="code-block">return a + b;</div>
					}
					<br>	
					int subtract(int a, int b){<br>
						<div class="code-block">return a - b;</div>
					}<br>
					<br>
					int multiply(int a, int b){<br>
						<div class="code-block">return a * b;</div>
					}<br>
					<br>	
					int division(int a, int b){<br>
						<div class="code-block">return a / b;</div>
					}<br>
					<br>
					int main(){<br>
						<div class="code-block">
							system("cls");<br>
							// - Variables definition<br>
							char option = '\0';<br>
							int valueA = 0, valueB = 0, result = 0;<br>
							<br>
							// - Values input<br>
							std::cout << "Insert value A: ";<br>
							std::cin >> valueA;<br>
							std::cout << "Insert value B: ";<br>
							std::cin >> valueB;<br>
							<br>
							system("cls");<br>
							<br>
							// - Operation input<br>
							std::cout << "Choose how to operate " << valueA << " and " << valueB << ": [+][-][*][/]\n";<br>
							std::cout << "> ";<br>
							std::cin >> option;<br>
							switch(option){<br>
							<div class="code-block">
									case '+':{<br>
										<div class="code-block">
											result = sum(valueA, valueB);<br>
											break;<br>
										</div>
									}<br>
									case '-':{<br>
										<div class="code-block">
											result = subtract(valueA, valueB);<br>
											break;<br>
										</div>
									}<br>
									case '*':{<br>
										<div class="code-block">
											result = multiply(valueA, valueB);<br>
											break;<br>
										</div>
									}<br>
									case '/':{<br>
										<div class="code-block">
											result = division(valueA, valueB);<br>
											break;<br>
										</div>
									}<br>
								</div>
							}<br>
							std::cout << valueA << option << valueB << "=" << result << std::endl;<br>
							return 0;<br>
						</div>
					}
				</div>
			</code>
			<p>Esse código mantém-se o mesmo independente de qual compilador usarmos.</p>
			<p>Abra o seu prompt de comando do VS SUTDIO 20**, copie o diretório do seu código fonte e cole na linha de comando como segue abaixo:</p>
			<code>CD C:/meu_diretorio</code>
			<p>O argumento CD seguido por um caminho(no caso a localização do seu "arquivo.cpp") define em que diretório o prompt de comando deve realizar seu trabalho.</p>

			<p>Ao usar o comando <var>CL</var> na linha de comando, estamos invocando o compilador CL.exe. Os argumentos de linha de comando para compilação usando CL.exe seguem a seguinte regra:</p>
			<code>CL [opção...] arquivo... [opção | arquivo]... [lib...] [@arquivo-de-comando] [/link opção-de-vinculador...]</code>
			<p>Uma vez que:</p>
			<ul>
				<li><var>opção</var>: uma ou mais opções do compilador. A tabela completa pode ser vista <a href="https://docs.microsoft.com/pt-br/cpp/build/reference/compiler-options-listed-by-category?view=msvc-170">aqui</a>. As opções também podem ser verificadas digitando <code>CL /HELP</code></li>
				<li><var>arquivo</var>: um ou mais arquivos de origem(código fonte), arquivos .obj ou bibliotecas. O CL compila os arquivos de origem e passa os .obj e bibliotecas para o vinculador.</li>
				<li><var>biblioteca</var>: uma ou mais nomes de bibliotecas. Esses nomes serão passados ao vinculador.</li>
				<li><var>arquivo-de-comando</var>: um arquivo contendo varias opções e nomes de arquivo. Arquivos de comando são úteis porque permitem definir as configurações de compilação em mais de uma linha de argumentos uma vez que a chamada ao CL.exe sem arquivos de comando aceita o limite de 1024 caractéres sem quebras de linha.</li>
				<li><var>opção-de-vinculador</var>: uma ou mais opções de vinculador. Essas opções serão passadas pelo CL ao vinculador.</li>
			</ul>
			
			<p>Desde que estejamos no diretório onde nosso código fonte esteja armazenado, vamos chamar o compilador MSVC usando o comando CL com os seguintes comandos:</p>
			<code>CL /EHsc calculator.cpp</code>
			<ul>
				<li><var>CL</var>: invoca o compilador CL.exe.</li>
				<li><var>/EHsc</var>: especifica o suporte ao modelo de manipulação de exceção gerado pelo compilador. Detalhes podem ser conferidos <a href="https://docs.microsoft.com/pt-br/cpp/build/reference/eh-exception-handling-model?view=msvc-170">aqui</a>.</li>
				<li><var>calculator.cpp</var>: o arquivo do qual queremos gerar um executável. O executável(.exe) de saída possuirá o nome do primeiro arquivo carregado, nesse caso, calculator.cpp.</li>
			</ul>
			<p>Após escrever o comando, pressione "Enter" para compilar. Nesse ponto, você deve obter dois arquivos de saída:</p>
			<ol>
				<li>Um arquivo .obj gerado a partir do código fonte. É importante não excluí-lo, se uma recompilação for necessária uma vez que o código fonte tenha sido atualizado, o compilador será capaz de avaliar quais partes no código binário mudaram e trabalhar apenas nisso salvando tempo no processo. Podemos indicar para o compilador que desejamos armazenar os arquivos .obj gerados em uma pasta especifica com intuito de melhor organizar nossos arquivos. Veremos adiante.</li>
				<li>O executável própriamente dito, nesses caso, calculator.exe.</li>
			</ol>
			<p>Com isso temos uma noção de como gerar executáveis com o compilador CL. Vamos começar a construir nossa primeira biblioteca estática.</p>
			<h3>Criando uma biblioteca estática</h3>
			<p>O princípio de uma biblioteca estática é disponibilizar uma série de funções bastante usuais em um arquivo e poder incluí-las em nossos projetos sempre quando demandarmos uso de suas funções. Vamos fazer isso de modo bastante simples movendo nossas funções de operações básicas com inteiros para um arquivo separado chamado "math.cpp". Também definiremos um arquivo de cabeçalho onde declaramos os protótipos de nossas funções. Note, o compilador precisa estar "preparado" para usar funções de arquivos externos, por isso usamos a diretiva "#include "math.hpp" para dizer que há funções definidas externamente sendo demandadas no arquivo atual.</p>
			<code>
				<div class="code-snippet">
					// - math.hpp<br>
					#ifndef MATH_HPP<br>
					#define MATH_HPP<br><br>
					int sum(int a, int b);<br>
					int subtract(int a, int b);<br>
					int multiply(int a, int b);<br>
					int division(int a, int b);<br><br>
					#endif<br>
				</div>
				<div class="code-snippet">				
					// - math.cpp<br>
					#include "math.hpp"<br>
					<br>
					int sum(int a, int b){<br>
						<div class="code-block">return a + b;</div>
					}<br>
					<br>
					int subtract(int a, int b){<br>
						<div class="code-block">return a - b;</div>
					}<br>
					<br>
					int multiply(int a, int b){<br>
						<div class="code-block">return a * b;</div>
					}<br>
					<br>
					int division(int a, int b){<br>
						<div class="code-block">return a / b;</div>
					}
				</div>
			</code>

			<p>Começaremos gerando o código binário da nossa biblioteca. Fazemos isso atráves do seguinte comando:</p>
			<code>CL /EShc math.cpp</code>
			<p>Em seguida chamamos o vinculador para gerar a biblioteca estática(.lib):</p>
			<code>LIB math.lib</code>
			<p>Por último associamos nossa biblioteca ao código fonte:</p>
			<code>CL /EHsc calculator.cpp math.lib</code>
			<p>Lembre-se de incluir o cabeçalho "math.hpp" em seu arquivo de origem, de outro modo, o compilador não poderá enontrar os símbolos para as funções da biblioteca vinculada.</p>
			
			<code>
				<div class="code-snippet">
					// - calculator.cpp<br>
					#include "math.hpp"<br>
					<br>
					#include &lt;iostream&gt;<br>
					<br>						
					int main(){<br>
						<div class="code-block">
							system("cls");<br>
							// - Variables definition<br>
							char option = '\0';<br>
							int valueA = 0, valueB = 0, result = 0;<br>
							<br>
							// - Values input<br>
							std::cout << "Insert value A: ";<br>
							std::cin >> valueA;<br>
							std::cout << "Insert value B: ";<br>
							std::cin >> valueB; <br>
							<br>
							system("cls");<br>
							<br>
							// - Operation input<br>
							std::cout << "Choose how to operate " << valueA << " and " << valueB << ": [+][-][*][/]\n";<br>
							std::cout << "> ";<br>
							std::cin >> option;<br>
							switch(option){<br>
								<div class="code-block">
									case '+':{<br>
										<div class="code-block">
											result = sum(valueA, valueB);<br>		
											break;<br>
										</div>
									}<br>
									case '-':{<br>
										<div class="code-block">
											result = subtract(valueA, valueB);<br>			
											break;<br>
										</div>

									}<br>
									case '*':{<br>
										<div class="code-block">
											result = multiply(valueA, valueB);<br>			
											break;<br>
										</div>
									}<br>
									case '/':{<br>
										<div class="code-block">
											result = division(valueA, valueB);<br>			
											break;<br>
										</div>
									}<br>
								</div>
							}<br>
							std::cout << valueA << option << valueB << "=" << result << std::endl;<br>
							return 0;<br>
						</div>
					}<br>
				</div>
			</code>
			
			<h2>Bibliotecas dinâmicas</h2>
			<p>Ao gerar bibliotecas dinâmicas 2 caminhos podem ser descritos:</p>
			<ul>
				<li>aquele por meio da geração de um arquivo .def</li>
				<li>aquele por meio da definição da diretiva de processamento __declspec(dllexport)</li>
			</ul>
			<h3>A diretiva __declspec(dllexport)</h3>
			<p>Ao criar dlls, precisamos declarar algumas coisas sobre as funções e recursos que um aplicativo que faça uso de tal dll precisa conhecer para realizar o processo de <var>exportação</var>.</p>
			<p>Uma exportação significa que um executavel deseja obter recursos de um arquivo externo. Por coesão, as funções públicas de uma dll(aquelas acessadas por outros aplicativos), devem ter seus protótipos preceditos pela palavra chave <var>extern</var> seguida pela palavra chave como segue: "C". Isso permite que mesmo que suas funções sejam escritas em C++, ao vincular, uma transição de simbólos compativéis com simbolos C serão criadas, o que é útil para que programas escritos em diferentes linguagens possam se comunicar com uma dll.</p>
			
			<p>Criar nossa dll requer um pequeno trabalho no arquivo de cabeçalho <var>math.hpp</var>, é nele que deixaremos as instruções para o compilador criar a dll.</p>
			<div class="code-snippet">
				<code>
					<pre>
					#ifndef MATH_H
					#define MATH_H

					#ifdef MATHLIBRARY_EXPORTS
					#define MATHLIBRARY_API __declspec(dllexport)
					#else
					#define MATHLIBRARY_API __declspec(dllimport)
					#endif

					extern "C" MATHLIBRARY_API int sum(int a, int b);
					extern "C" MATHLIBRARY_API int subtract(int a, int b);
					extern "C" MATHLIBRARY_API int multiply(int a, int b);
					extern "C" MATHLIBRARY_API int division(int a, int b);

					#endif
					</pre>
				</code>
			</div>

			<p>O comando de linha para gerar dlls é este:</p>
			<code>CL source.cpp /link /DLL /OUT:output.dll </code>
			<p>Em que, <var>source</var> é seu arquivo de origem que possui a implementação de suas funções e <var>output</var> a dll gerada.</p>
			<p>Devido ao fato de usarmos a diretiva declspec(dllexport), isso é tudo o que precisamos fazer. Serão gerados três arquivos de saída:</p>
			<ul>
				<li><var>.lib</var>: o arquivo que contém os simbolos necessários durante a vinculação.</li>
				<li><var>.exp</var>: o arquivo cuja finalidade será descrita adiante.</li>
				<li><var>.dll</var>: a biblioteca de vincula dinâmico.</li>
			</ul>
			<p>O código em <var>calculator.cpp</var> permanece o mesmo. Para vincular, usaremos o seguinte trecho:</p>
			<code>CL /EHsc calculator.cpp math.lib</code>
			
			<p>Há muitas coisas mais a serem discutidas sobre bibliotecas de vinculo dinâmico, contudo, com o que sabemos até agora, podemos trabalhar com certa liberdade produzindo nossas bibliotecas. Pratique e pratique, assim poderá seguir aprendendo cada vez mais.</p>

			<br>
			<var>Revisar texto até aqui, após escrever sobre a criação de bibliotecas dinâmicas.</var><br>
			<var>Write at 11/04/2022</var>

			<div hidden>
			<h3>Extensões</h3>
			<p>Para gerar bibliotecas dinâmicas, é preciso obter:</p>
			<ul>
				<li>.o: arquivo de objeto, é a primeira sáida direta que um compilador deve emitir e a primeira entrada de um vinculador.</li>
				<li>.so/.dll: a biblioteca dinâmica em si gerada apartir do arquivo .o e tendo os devidos sinalizadores configurados.</li>
			</ul>
			<p>Para gera bibliotecas estáticas, é preciso obter:</p>
			<ul>
				<li>.o: já mencionado.</li>
				<li>.a: arquivo "arquivos"(análgos aos arquivos zip, porém sem compatação). Consistem em um ou um grupo de arquivos .o(ou qualquer outro) empacotados como uma biblioteca e que deverão ser inseridos no vinculador.</li>
			</ul>
			<p>Vamos usar o mingw-w64 para compilar construir nossas bibliotecas.</p>
			<p>Gerando uma biblioteca dinâmica:</p>
			<code>
				g++ output.cpp -c -fpic<br>
				g++ output.o -shaded -o output.dll<br>
			</code>
			<p>Em sistemas Unix, .so são equivalentes as .dll do windows.</p>
			<p>Gerando uma biblioteca dinâmica</p>

			<code>
				g++ output.cpp -c -fpic<br>
				# aqui geramos um arquivo .o<br><br>
				
				# apartir do arquivo.o, criaremos um arquivo de "arquivos". <br>
				ar rcs liboutput.a output.o<br><br>
				
				g++ main.cpp -L. -lstd=c++03 -loutput -o main.exe<br>
				# vinculamos a nossa biblioteca estatica ao arquivo "main.cpp"<br>
				# -L. indica que todos os arquivos necessários para compilação estão no diretório atual<br>
				# -lstd=c++03 deve ser indicada caso use cabeçalhos da linguagem na sua biblioteca<br>
				# -loutput, -l indica que incluiremos arquivos de biblioteca, nesse caso, liboutput.a(note a omissão do prefixo "lib" e sufixo "a", o compilador é capaz de antecipar essas informações).<br>
			</code>
			<p> .a é definida para sistemas Unix, enquanto no windows, o equivalente a bibliotecas estáticas é .lib.</p>
			<p>.lib são usadas para vincular algum código a uma dll gerada o MS Visual C++(compilador prpietário do Windos). Elas contém "wrrapers" simples que invocam a dll respectiva. Em sistemas Unix, o linker é inteligente o suficiente para gerá-los em tempo real, por isso você não terá que definir um (equivalente) .a para vincular uma dll em seu projeto.</p>
			</div>
		
		<p>Referências:</p>
		<p></p><a href="https://docs.microsoft.com/pt-br/cpp/build/reference/compiler-command-line-syntax?view=msvc-170"> https://docs.microsoft.com/pt-br/cpp/build/reference/compiler-command-line-syntax?view=msvc-170</a></p>
		</section>
		
		<footer class="col-s-12 col-t-12 col-d-12">
			<span class="col-s-12 col-t-12 col-d-2"><a href="index.html">Apresentação</a></span>
			<span class="col-s-12 col-t-12 col-d-12"><a href="tutoriais.html">Tutoriais</a></span>
			<span class="col-s-12 col-t-12 col-d-12"><a href="reference.html">Referência</a></span>
			<span class="col-s-12 col-t-12 col-d-12"><a href="https://github.com/renatopdmoura/pura-project.git" target="_blank">Download</a></span>
			<span id="copyright" class="col-s-12 col-t-12 col-d-12">&copy 2022 ImCreate</span>
		</footer>
	</main>
</body>
</html>