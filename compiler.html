<!DOCTYPE html>	
<html>
<head>
	<title>ImCreate</title>
	<meta charset="UTF-8">
	<meta name="description" content="Referência">
	<meta name="keywords" content="Programação, C++, OpenGL">
	<meta name="author" content="Renato Moura">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- include css -->
	<link rel="stylesheet" href="css/common.css" type="text/css">
	<link rel="stylesheet" href="css/tutoriais.css" type="text/css">
	<!-- include javascript -->
	<script type="text/javascript" src="js/javascript.js"></script>
</head>
<body>
	<main id="main-container" class="row">
		<header id="main-header" class="col-s-12 col-t-12 col-d-12">
			<div id="main-title" class="col-s-12 col-t-5 col-d-5">
				<h1>ImCreate</h1>
			</div>
			<nav class="col-s-12 col-t-7 col-d-7 row">
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="index.html" class="link-menu">Apresentação</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="tutoriais.html" class="link-menu">Tutoriais</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="reference.html" class="link-menu">Referência</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="https://github.com/renatopdmoura/pura-project.git" target="_blank" accesskey="t" class="link-menu">Download</a></span>
			</nav>
		</header>
		<section class="col-s-12 col-t-12 col-d-12 content Compiler-Concepts">
			<h2>Conceitos de Compilação</h2>
			<p>Antes de comerçarmos a desenvolver projetos em C++ é de suma importância aprender sobre o trabalho que os compiladores realizam para gerar um arquivo executável.</p>
			
			<var>&lt;Escrever sobre o funcionamento de um compilador&gt;</var>

			<p>Um compilador é um software capaz de transformar código fonte em linguagens de alto nível em código de linguagens de baixo nível chamado de <var>código binário</var>(como código de máquina e assembly). O código então gerado é voltado ao uso de determinado tipo de arquitetura de processamento(CISC ou RISC).</p>

			<p>Um compilador possui um pipeline de estágios, onde a saída de um estágio anterior é a entrada para o próximo estágio.</p>
			<p>A compilação possui duas fases, sendo elas:</p>
			<ul>
				<h3>Análise</h3>
				<p>Análise léxica: o código fonte original é transformado em um fluxo de caracteres que será convertido em lexemas(a menor unidade simbólica de um linguagem) conhecidos como <var>tokens</var>. A tradução a tokens depende da linguagem de alto nível utilizado, por exemplo em C++:</p>
				<ul>
					<code>
						<pre>
						unsigned int value = 8;
						// unsigned int é um token "keyword"
						// value é um token "identifier"
						// = é um token "operator"
						// 8 é um token "constant"
						// ; é um token "symbol"
						</pre>
					</code>
				</ul>
				<p>Análise sintática: busca por tokens inválidos que o analisador léxico tenha julgado como corretos. O analisador sintático busca por símbolos não terminais(como variáveis), símbolos terminais(determinados pela linguagem), regras combinatórias para terminais e não terminais gerarem <var>strings</var> e símbolos de partida.</p>
				<p>Análise semântica: verifica se há coerência linguística entre os tokens definidos, se váriaveis foram declaradas e inicializadas...</p>
				<h3>Síntese</h3>
				<p>Código intermediário: após as traduções das etapas de análise, um código independente de máquina é gerado para então o compliador gerar um código especifico para determianda arquitetura. Essa fase de gerar código intermediário aumenta a portabilidade e seguementação de código pois torna menos complexo a conversão para linguagem de máquina.</p>
				<p>Otimização de código independente de máquina: o compilador toma liberdade em realizar ajustes uma vez que reescrever o código de tal modo diminua a carga em processamento e gerenciamento de memória.</p>
				<p>A etapa final pode ser descrita como a geração do código em si em linguagem de baixo nível, o qual carrega o exato significado do código fonte original e otimizado de acordo.</p>
			</ul>
			<p>A saída final direta de um compilador são designados como arquivos de objeto e são o código binário respectivo do código fonte de alto nível gerado no processo de compilação. Esses arquivos são conhecidos por ter extensão .o(gcc) ou .obj(MSVC), e por vezes, um conjunto de arquivos de objeto podem ser armazenados em um mesmo lote de arquivo afim de permitir otimizações no momento da vinculação do código binário. Esse conjunto de arquivos de objetos pode ser referido como uma <var>biblioteca</var> e são comumente arquivados(analogamente a arquivos zip) sob a extensão de arquivo .a(gcc) ou .lib(MSVC) afim de serem usados no processo de <var>vinculação</var>. A etapa de vinculação é tida, de forma resumida, como o momento final antes da geração de um executavel. O vinculador recebe arquivos .o/.obj, .a/.lib .so/.dll e realiza um processo de linkedição determinada pelos sinalizadores definidos na linha de comando gerando um arquivo de objeto de saída que torna-se-á o executavel final.</p>
				
			<p>Com essa introdução, temos um breve, mas suficiente entendimento para aprender a compilar nossos projetos. Um bom primeiro passo e começar explanando sobre a geração de bibliotecas.</p>

			<h3>Indo por partes</h3>
			<p>Quando estamos trabalhando em um projeto, não são poucas as séries de funções que estão dispóniveis para nosso uso. Em diferentes arquivos estas funções podem ser acessadas de modo que exista apenas um lugar(ou espandidas como um macro) de declaração e implementação para elas. Isso só é possível pela existência de bibliotecas(como um conjunto de funções dispostos a resolver uma determinada área de problemas), e essas bibliotecas podem ser ditas como: estáticas ou dinâmicas.</p>
			<h3>Bibliotecas estáticas</h3>
			<p>Bibliotecas estáticas tem a extensão .a ou .lib(essa variação depende do compilador usado para gerá-las). Bibliotecas estáticas são feitas para serem usadas em qualquer programa apenas com a diretiva de inclusão "#include" adicionando o caminho dos arquivos de cabeçalho a serem acessados. O que é singular sobre uma biblioteca estática é, que para cada arquivo em seu projeto que a inclua será gerada um cópia em tempo de compilação dos recursos da biblioteca estática para o escopo do arquivo que a inclui. Isso tem por efeito, que uma vez gerado um executável, a biblioteca fará parte do contéudo do executavel de modo que se possíveis atualizações futuras da biblioteca forem necessárias, deve-se recompilar todo o código fonte.</p>
			<p>A vantagem é na garantia de não corrupção dos arquivos como ocorre com as dlls(uma biblioteca estática compilada ao código fonte só para se o executavél parar), além de suas funções serem mais rápidas de acessar pois a busca pelos protótipos estão no escopo do arquivo em contrapartida a bibliotecas dinâmicas, as quais funcioanam como recurso externo.</p>
			
			<h3>Bibliotecas dinâmicas</h3>
			<p>Bibliotecas dinâmicas não sofrem dos mesmos males de um biblioteca estática. Elas são normalmente referidas pela extensão .dll e têm o potêncial de serem economicas. Bibliotecas dinâmicas diferentemente das estáticas não são anexadas ao escopo dos arquivos que fazem chamadas as suas funções, mas sim o programa gera apenas uma cópia em tempo de compilação de seus recursos. Como mencionado anteriormente, elas atuam como um meio externo de modo que quando as associamos aos nossos projetos, chamadas as suas funções demandariam um tempo extra para desviar o fluxo de leitura atual para fora do executável solicitando o uso de determinadas funções. O bônus de uma dll está em sua portabilidade e eficiência. Usar dlls reduz o peso do arquivo final, já que não serão feitas cópias para cada arquivo que usa seus recursos, e, do ponto de vista da eficiência, caso novas alterações sejam necessárias para a biblioteca, desde que o fluxo de trabalho não mude não há necessidade de recompilar todo código fonte do seu projeto e sim apenas substiruir a dll no diretório de origem.</p>
			<p>Bibliotecas dinâmicas são também compartilhadas. Se você for até o diretório system32, verá muitas dlls, seria impressionante dizer que diferentes programas que usamos associam-se a uma mesma dll paralelamente?</p>

			<p>A conclusão sobre qual tipo de biblioteca usar depende em si do modo que ela será distribuída. Caso seja um recurso com baixa probalidade de ser mutável e focado a atender tarefas especificas de uma determinada aplicação, bibliotecas estáticas são uma boa escolha. Bibliotecas dinâmicas funcionam no outro lado da moeda. No fim, provavelmente você irá usar um misto em seus projetos(principalmente porque fazemos usos de bibliotecas desenvolvidas por terceiros), e (quase)sempre será uma questão de analise do seu projeto e o quanto ele pode ser reaproveitado por futuros projetos além de pesar entre eficiência de espaço(bibliotecas dinâmicas) e eficiência de processamento(bibliotecas estáticas).</p>

			<h2>Resumindo</h2>
			
			<p>Caso seja muita informação para assimilar, resalto que o importante à saber é:</p>

			<h3>Bibliotecas estáticas</h3>
			<P>Cada arquivo que os inclui fará uma cópia de suas funções/dados para o escopo do arquivo em tempo de compilação.</P>
			<p>Uma vez gerado o executavel, as funções/dados da biblioteca estática só podem ser atualizados por recompilação.</p>
			<h4>Vantagens</h4>
			<p>Não corrompem(pois estão atreladas ao binário do executavel.</p>
			<p>São rápidas de acessar(pois existem no escopo do arquivo que as inclui permitindo otimizações de chamada se possível).</p>
			<p>Enquanto salvam processamento, consomem espaço.</p>
			<h3>Bibliotecas Dinâmicas</h3>
			<p>As funções/dados de uma biblioteca dinâmica existem em um arquivo separado ao executavel que as usa. Assim, múltiplos arquivos em um executável acessam uma única cópia das funções/dados determinada em tempo de compilação.</p>
			<p>Bibliotecas dinâmicas podem ser atualizadas sem a necessidade de recompilação.</p>
			<p>São econômicas, pois um único arquivo é usado por toda aplicação, contudo, perdem em desempenho uma vez que é preciso desviar o fluxo de execução para um arquivo externo durante as chamadas à funções da biblioteca.</p>
			<p>São sucetiveis a corrupção de arquivos.</p>
			<p>Uma mesma dll(biblioteca dinâmica) pode ser usada paralelamente por multiplos programas.</p>
			
			<h2>Praticando</h2>
			<p>Estamos preparados para ter alguma pratica. Vamos começar gerando bibliotecas estáticas usando dois compiladores distintos, sendo o MSVC e o GCC. Os executáveis gerados pelos diferentes compiladores deverão funcionar da mesma forma. Por fim, vamos também criar um biblioteca dinâmica como exemplo.</p>

			<h3>Usando o MSVC</h3>
			<p>O MSVC é um compilador pertencente a Microsoft. Ele costuma acompanhar a IDE do Visual Studio. Você pode fazer o download da IDE <a href="https://visualstudio.microsoft.com/pt-br/downloads/">aqui</a>.</p>
			<p>Após instalar a IDE, navegue até encontrar a seção do Visual Studio, encontre sua pasta então escolha entre x64 Native Tools Command Prompt for VS 2019/x86 Native Tools Command Prompt for VS 2019 dependendo do seu sistema operacional(64 ou 32 bits respectivamente).</p>
			<p>Iremos criar um simples programa para realizar cálculos de operações básicas com inteiros afim de experimentar os compiladores escolhidos. O código fonte será este:</p>
			<code>
				<pre>
					#include &lt;iostream&gt;
					
					int sum(int a, int b){
						return a + b;
					}
						
					int subtract(int a, int b){
						return a - b;
					}
					
					int multiply(int a, int b){
						return a * b;
					}
						
					int division(int a, int b){
						return a / b;
					}
						
					int main(){
						system("cls");
						// - Variables definition
						char option = '\0';
						int valueA = 0, valueB = 0, result = 0;
						
						// - Values input
						std::cout << "Insert value A: ";
						std::cin >> valueA;
						std::cout << "Insert value B: ";
						std::cin >> valueB; 
						
						system("cls");
					
						// - Operation input
						std::cout << "Choose how to operate " << valueA << " and " << valueB << ": [+][-][*][/]\n";
						std::cout << "> ";
						std::cin >> option;
						switch(option){
							case '+':{
								result = sum(valueA, valueB);			
								break;
							}
							case '-':{
								result = subtract(valueA, valueB);			
								break;
							}
							case '*':{
								result = multiply(valueA, valueB);			
								break;
							}
							case '/':{
								result = division(valueA, valueB);			
								break;
							}
						}
						std::cout << valueA << option << valueB << "=" << result << std::endl;
						return 0;
					}
				</pre>
			</code>
			<p>Esse código mantém-se o mesmo independente de qual compilador usarmos.</p>
			<p>Abra o seu prompt de comando do VS SUTDIO 20**, copie o diretório do seu código fonte e cole na linha de comando como segue abaixo:</p>
			<code>CD C:/meu_diretorio</code>
			<p>O argumento CD seguido por um caminho(no caso a localização do seu .cpp) define em que diretório o prompt de comando deve realizar seu trabalho.</p>

			<p>Ao usar o comando <var>CL</var> na linha de comando, estamos invocando o compilador cl.exe. Os argumento de linha de comando para compilação usando cl.exe seguem a seguinte regra:</p>
			<code>CL [opção...] arquivo... [opção | arquivo]... [lib...] [@arquivo-de-comando] [/link opção-de-vinculador...]</code>
			<p>Uma vez que:</p>
			<ul>
				<li>opção: uma ou mais opções do compilador. A tabela completa pode ser vista <a href="https://docs.microsoft.com/pt-br/cpp/build/reference/compiler-options-listed-by-category?view=msvc-170">aqui</a>. As opções também podem ser verificadas digitando <code>CL /HELP</code></li>
				<li>arquivo: um ou mais arquivos de origem(código fonte), arquivos .obj ou bibliotecas. O CL compila os arquivos de origem e passa os .obj e bibliotecas para o vinculador.</li>
				<li>biblioteca: uma ou mais nomes de bibliotecas. Esses nomes serão passados ao vinculador.</li>
				<li>arquivo-de-comando: um arquivo contendo varias opções e nomes de arquivo. Arquivos de comando são úteis pos permitem definir as configurações de compilação em mais de uma linha de argumentos uma vez que a chamada ao CL.exe aceita o limite de 1024 caractéres.</li>
				<li>opção-de-vinculador: uma ou mais opções de vinculador. Essas opções serão passadas pelo CL ao vinculador.</li>
			</ul>
			
			<p>Desde que estejamos no diretório onde nosso código fonte esteja armazenado, vamos chamar o compilador MSVC usando o comando CL com os seguintes comandos:</p>
			<code>CL /EHsc calculator.cpp</code>
			<ul>
				<li>CL: invoca o compilador CL.exe.</li>
				<li>/EHsc: especifica o suporte ao modelo de manipulação de exceção gerado pelo compilador. Detalhes podem ser conferidos <a href="https://docs.microsoft.com/pt-br/cpp/build/reference/eh-exception-handling-model?view=msvc-170">aqui</a>.</li>
				<li>calculator.cpp: o arquivo do qual queremos gerar um executável. O executável(.exe) de saída possuirá o nome do primeiro arquivo carregado, nesse caso, calculator.cpp.</li>
			</ul>
			<p>Após escrever o comando, pressione enter para compilar. Nesse ponto, você deve obter dois arquivos de saída:</p>
			<ol>
				<li>Um arquivo .obj gerado a partir do código fonte. É importante não excluí-lo, se uma recompilação for necessária uma vez que o código fonte tenha sido atualizado, o compilador será capaz de avaliar quais partes no código binário mudaram e trabalhar apenas nisso salvando tempo no processo. Podemos indicar para o compilar que desejamos armazenar os arquivos .obj gerados em uma pasta especifica com intuito de melhor organizar nossos arquivos. Veremos adiante.</li>
				<li>O executável própriamente dito, nesses caso, calculator.exe.</li>
			</ol>
			<p>Com isso temos uma noção de como gerar executáveis com compilador CL. Vamos começar a construir nossa primeira biblioteca estática.</p>
			<p>O princípio de uma biblioteca estática é disponibilizar uma série de funções bastantes usuais em um arquivo e poder inclui-las em nossos projetos sempre quando demandarmos uso de suas funções. Vamos fazer isso de modo bastante simples movendo nossas funções de operações básicas com inteiros para um arquivo separado chamado "math.cpp"</p>
			<var>Write at 10/04/2022</var>

			<div hidden>
			<h3>Extensões</h3>
			<p>Para gerar bibliotecas dinâmicas, é preciso obter:</p>
			<ul>
				<li>.o: arquivo de objeto, é a primeira sáida direta que um compilador deve emitir e a primeira entrada de um vinculador.</li>
				<li>.so/.dll: a biblioteca dinâmica em si gerada apartir do arquivo .o e tendo os devidos sinalizadores configurados.</li>
			</ul>
			<p>Para gera bibliotecas estáticas, é preciso obter:</p>
			<ul>
				<li>.o: já mencionado.</li>
				<li>.a: arquivo "arquivos"(análgos aos arquivos zip, porém sem compatação). Consistem em um ou um grupo de arquivos .o(ou qualquer outro) empacotados como uma biblioteca e que deverão ser inseridos no vinculador.</li>
			</ul>
			<p>Vamos usar o mingw-w64 para compilar construir nossas bibliotecas.</p>
			<p>Gerando uma biblioteca dinâmica:</p>
			<code>
				g++ output.cpp -c -fpic<br>
				g++ output.o -shaded -o output.dll<br>
			</code>
			<p>Em sistemas Unix, .so são equivalentes as .dll do windows.</p>
			<p>Gerando uma biblioteca dinâmica</p>

			<code>
				g++ output.cpp -c -fpic<br>
				# aqui geramos um arquivo .o<br><br>
				
				# apartir do arquivo.o, criaremos um arquivo de "arquivos". <br>
				ar rcs liboutput.a output.o<br><br>
				
				g++ main.cpp -L. -lstd=c++03 -loutput -o main.exe<br>
				# vinculamos a nossa biblioteca estatica ao arquivo "main.cpp"<br>
				# -L. indica que todos os arquivos necessários para compilação estão no diretório atual<br>
				# -lstd=c++03 deve ser indicada caso use cabeçalhos da linguagem na sua biblioteca<br>
				# -loutput, -l indica que incluiremos arquivos de biblioteca, nesse caso, liboutput.a(note a omissão do prefixo "lib" e sufixo "a", o compilador é capaz de antecipar essas informações).<br>
			</code>
			<p> .a é definida para sistemas Unix, enquanto no windows, o equivalente a bibliotecas estáticas é .lib.</p>
			<p>.lib são usadas para vincular algum código a uma dll gerada o MS Visual C++(compilador prpietário do Windos). Elas contém "wrrapers" simples que invocam a dll respectiva. Em sistemas Unix, o linker é inteligente o suficiente para gerá-los em tempo real, por isso você não terá que definir um (equivalente) .a para vincular uma dll em seu projeto.</p>
			</div>
		
		<p>Referências:</p>
		<p></p><a href="https://docs.microsoft.com/pt-br/cpp/build/reference/compiler-command-line-syntax?view=msvc-170"> https://docs.microsoft.com/pt-br/cpp/build/reference/compiler-command-line-syntax?view=msvc-170</a></p>
		</section>
		
		<footer class="col-s-12 col-t-12 col-d-12">
			<span class="col-s-12 col-t-12 col-d-2"><a href="index.html">Apresentação</a></span>
			<span class="col-s-12 col-t-12 col-d-12"><a href="tutoriais.html">Tutoriais</a></span>
			<span class="col-s-12 col-t-12 col-d-12"><a href="reference.html">Referência</a></span>
			<span class="col-s-12 col-t-12 col-d-12"><a href="https://github.com/renatopdmoura/pura-project.git" target="_blank">Download</a></span>
			<span id="copyright" class="col-s-12 col-t-12 col-d-12">&copy 2022 ImCreate</span>
		</footer>
	</main>
</body>
</html>