<!DOCTYPE html>	
<html>
<head>
	<title>ImCreate</title>
	<meta charset="UTF-8">
	<meta name="description" content="Referência">
	<meta name="keywords" content="Programação, C++, OpenGL">
	<meta name="author" content="Renato Moura">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- include css -->
	<link rel="stylesheet" href="css/common.css" type="text/css">
	<link rel="stylesheet" href="css/tutoriais.css" type="text/css">
	<!-- include javascript -->
	<script type="text/javascript" src="js/javascript.js"></script>
</head>
<body>
	<main id="main-container" class="row">
		<header id="main-header" class="col-s-12 col-t-12 col-d-12">
			<div id="main-title" class="col-s-12 col-t-5 col-d-5">
				<h1>ImCreate</h1>
			</div>
			<nav class="col-s-12 col-t-7 col-d-7 row">
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="index.html" class="link-menu">Apresentação</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="tutoriais.html" class="link-menu">Tutoriais</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="reference.html" class="link-menu">Referência</a></span>
				<span class="col-s-12 col-t-12 col-d-3 item-menu"><a href="https://github.com/renatopdmoura/pura-project.git" target="_blank" accesskey="t" class="link-menu">Download</a></span>
			</nav>
		</header>
		<section class="col-s-12 col-t-12 col-d-12 content">
			<h2>Versão 0.4.0</h2>
			<p>Esta seção descreve o novo fluxo de trabalho mais limpo, simples e eficiente para objetos do tipo GUI.</p>
			<p>'Box' é uma classe especializada em criar um elemento visual(um quad) cuja propriedades podem ser definidas para ser usado como um painel ou botões.</p>
			<p>A lista de propriedades busca seguir o padrão encontrado em CSS usado para formatação de sites por ser clara e intuitiva. As propriedades são, respectivamente:</p>
			<ul>
				<li>Posição</li>
				<li>Largura e Altura</li>
				<li>Preenchimento interno</li>
				<li>Bordas</li>
				<li>Espessura de bordas</li>
				<li>Cor de borda</li>
				<li>Máscaras de bordas</li>
				<li>Arredondamento de extremidades</li>
				<li>Preenchimento interno</li>
				<li>Margens</li>
				<li>Cor de plano de fundo</li>
				<li>Imagem de plano de fundo</li>
			</ul>

			<p>Uma instância de 'Box' disponibiliza a definição de funções para manipulação de determinados eventos(como sobrepor o mouse e selecionar) por meio de atríbutos do tipo std::function desde que tenham um retorno de chamada do tipo <var>void</var> e parêmtro de igual tipo. Os atríbutos e eventos que os manipulam são listados a baixo:</p>
			<ul>
				<li>initial: o atríbuto <var>initial</var> espera que dentro de seu escopo seja determinada o comportamento/formatação padrão de determinado objeto(podendo ser qualquer objeto dentro do mesmo escopo em que <var>initial</var> é definido). Esse é um atríbuto que muda o estado do objeto referido dentro de seu escopo sempre que nenhum evento
				para o objeto chamador estiver sendo processado.</li>
				<li>over: o atríbuto que define o comportamento para objetos referidos em seu escopo sempre que o mouse estiver sobre a instância que chama 'over'.</li>
				<li>click: o atríbuto que define o comportamento para objetos referidos em seu escopo sempre que um clique com o botão esquerdo do mouse for detectado sobre a instância que chama 'click'</li>
			</ul>

			<p>Objetos da classe GUI mantém uma relação de herança de modo que objetos filhos possam compartilhar propriedades em comum e em relação ao seu objeto pai. As seguintes propriedades são descritas:</p>
			<ul>
				<li>Posição relativa a posição do objeto pai</li>
				<li>Dimensão proporcional a dimensão do objeto pai</li>
				<li>Visibilidade relativa a visibilidade do objeto pai</li>
			</ul>

			<p>O fluxo de renderização e processamento torna-se simples quando a biblioteca armazena toda instância(especializada) da classe GUI em um vetor de ponteiros de modo que processar todos os eventos disponíves possa ser realizado pela chamada as seguintes funções membro estáticas:</p>
			<ul>
				<li>GUI::RenderWithColorID(): essa função é crucial par que um objeto GUI tenha utílidade. Ao renderizar cada instância criada com uma cor especifica, a biblioteca torna-se capaz de ler do buffer de cor e determinar sobre qual objeto o mouse está para então chamar o respectivo evento esperado(note, o processamento de eventos não é tarefa de GUI::RenderWithColorID()).</li>
				<li>GUI::ColorPicking(): como o nome sugere, a função usa a tecnica de seleção de cores para ordenar, mover, realçar(definindo <var>over</var>), ou tornar a configuração inicial(definindo <var>initial</var>). Note: objetos filhos não serão processados por esta função.</li>
				<li>GUI::MouseEvent(): Essa função é responsável por processar e válidar o evento de seleção de um objeto pelo mouse.</li>
			</ul> 
			<p>Um objeto pode ter uma tecla atríbuida (como a maioria dos eventos de interface gráfica são projetados para serem disparados pelo mouse, atríbuir uma tecla é útil como um atalho para exibição do objeto, contudo, qualquer comportamento pode ser definido no escopo do atríbuto membro <var>keypress</var>. Exemplos serão apresentados). Eventos de teclado para todos objetos podem ser processado a partir de uma única chamada à GUI::KeyboardEvent().</p>

			<p>A renderização real de objetos do tipo GUI é feita pela chamada única à GUI::Render(). Note: objetos podem ser renderizados e ter seus eventos processados individualmente por meio a chamadas explicitas as funções membros correspondente, contudo, faça isso apenas se for estritamente necessário remover tal objeto do vetor interno de objetos(o que raramente deve vir a acontecer. Exemplos serão apresentados posteriormente).</p>

			<p>Até aqui uma visão abstraída de como funciona o fluxo de trabalhao com objetos de interface de usuário foi apresentada. Ademais, apresenta-se o real implementação, levando em conta parâmetros de funções(omitidos para diminuir o assunto técnico) e a configuração dos ativos compartilhados pelo biblioteca(como sombreadores e texturas) além de como deve ser o corpo da função principal.</p>

			<ol style="background-color: #eee; padding: 30px;">
				Próxima tarefa:
				<li>Trazer exemplos de códigos(stack/heap).</li>
				<p style="font-size: 0.85em;">Atualizado em 25/05/2022</p>
			</ol>


			<h2>Versão 0.3.0 - Legada, novas versões mudam drasticamente o fluxo de trabalho interno.</h2>
			<h1>Interface Grágica de Usuário</h1>
			<section id="Introduction">
				<h2>Introdução</h2>				
				<p>Os recursos de interface gráfica de usuário - GUI - fazem parte da biblioteca 'Imcreate' sendo inteiramente desenvolvida usando os príncipios de renderização OpenGL.</p>
				<p>Para começar a usar objetos do tipo GUI, deve-se fazer a inclusão do arquivo de cabeçalho em "libraries/GUI/GeneralGUI.hpp".</p>
				<p>Todos os objetos de interface gráfica compartilham funções e dados em comum com a classe base GUI. Dado tal, cada especialização da classe possui sua lógica própria de construção.</p>
				<p>Objetos do tipo GUI são mantidos por uma pilha interna para chamadas de renderização e processamento da fila de eventos sejam gerenciadas por uma única chamada de função sendo respectivamente:</p>
				<ul>
					<li>GUI::stackPicking(): para habilitar a seleção de objetos do tipo GUI.</li>
					<li>GUI::stackRender(): para renderizar todos objetos do tipo GUI criados.</li>
					<li>GUI::stackPollEvent(SDL_Event* event): para processar os eventos de todos objetos GUI criados.</li>
				</ul>
				<p>Salvo alguns, criar objetos do tipo GUI requer apenas o trabalho de construção sem necessitar preocupar-se com seu tratamento após isso.</p>
				<h3>Relacionamento</h3>
				<p>Todo objeto do tipo GUI pode manter uma relação pai-filho com outro objeto. Isso permite que objetos tenha sua posição, dimensão e visibilidade relativos ao objeto pai. Como um relacionamento um para muitos, o objeto pai será sempre o último definido.</p>
				<p>Para tornar um objeto agregado a outro, após construir ambos objetos, chame a função pública <code>push(GUI* guiObject)</code>:</p>
				<code>
					father.push(&children);
				</code>
				<h4>Exemplo:</h4>
				<code>
					<pre>
					Panel panel000(50.0f, 50.0f, 20.0f, 45.0f, 6.0f, vec4&lt;float&gt;(0.2f, 0.19f, 0.22f), vec4&lt;float&gt;(0.65f, 0.34f, 0.2f), vec4&lt;float&gt;(0.2f, 0.2f, 0.2f));
					Text title000("../assets/fonts/Humnst777.ttf", 18.0f, 50.0f, 50.0f, vec3&lt;float&gt;(0.9f), "PANEL000", ON_HEADER);
					panel000.push(title000);
					</pre>
				</code>
				<p> O código anteriror criar o seguinte resultado:</p>
				<img src="media/img/panel000_title000.png" class="img-ex"/>
				<p>"Text" é mais um tipo de objeto GUI. Seu construtor aceita um caminho para fonte a ser usada, o tamanho da fonte em pixels, sua posição, cor da fonte, a string a ser exibida e o layout de posicionamento.</p>
				<h3>Eventos</h3>
				<p> Um aspecto crucial de uma interface de usuário é operar eventos com base na ação do usuário. Eventos especiais podem ser criados
				a partir de um função lambda passada como parâmetro da função <code>setUserEvent([&](){ /***meu evento***/ })</code>.</p>
				<h4>Exemplo:</h4>
				<code>
					<pre>
					...
					title000.setUserEvent([&](){
						panel000.setHidden(true);
					});
					</pre>
				</code>
				<p>O bloco de código anterior irá esconder o objeto painel000 quando o usuário clicar sobre o título do painel.</p>
				<h3>Topologia</h3>
				<p>A relação hereditária das classes de interface gráfica são represnetadas no diagrama abaixo:</p>
				<img src="media/img/gui_topology.png" class="img-ex">
			</section>

			<section id="Text">
				<h2>Usando textos</h2>
				<p>Textos são a essência da interface de usuário. A classe Text é especializada em renderizar textos com suporte a unicode. Um objeto Text pode associar-se a outros objetos GUI e sua construção é ser tal como a definição a seguir:</p>
				<code>
					<pre>
					Text text("Humnst777.ttf", 18.0f, 50.0f, 50.0f, vec3<float>(0.9f), "Eu sou um simples texto", ON_HEADER);
					</pre>
				</code>
				<p>Onde os parâmetros são, em ordem respectiva:</p>
				<uL>
					<li>std::string: o nome da fonte(espera-se que a fonte esteja no diretório "assets/fonts".</li>
					<li>float font_size: o tamanho da fonte em pixels.</li>
					<li>float x: a proporção de posicionamento x.</li>
					<li>float y: a proporção de posicionamento y.</li>
					<li>vec3&lt;float&gt; color: a cor do texto.</li>
					<li>std::string: os caractéres a serem escritos.</li>
					<li>GUI_PanelLayout: o layout de painel(se pertencer a um painel).</li>
				</uL>
			</section>
			
			<section id="Panel">
				<h2>Criando Painéis</h2>
				<p>Painéis são idealmente contâiners para um grupo de objetos. Por padrão, painéis são criados com a região do cabeçalho como a área de eventos - como agarrar e selecionar.</p>
				<p>Para grande maioria dos casos, questões visuais e de posicionamento são decidas no construtor do objeto:</p>
				<code>
					<pre>
					Panel panel000(float x, float y, float w, float h, float thickness, vec4&lt;float&gt; backgroundColor, vec4&lt;float&gt; headerColor, vec4&lt;float&gt; borderColor,<wbr> GUI_PanelLayout panelLayout = ON_WINDOW);
					</pre>
				</code>
				<p>Os parâmetros <code>x, y</code> e <code>w, h</code> dizem respeito ao posicionamento e dimenções do painel respectivamente dados em porcentagem.</p>
				<p>Há ainda outra versão do construtor que recebe escalas de resolução para serem tratadas de acordo com a mudança de tamanho da janela da aplicação:</p>
				<code>
					<pre>
					Panel panel000(float x, float y, std::vector&lt;vec2&lt;float&gt;&gt; scales, float thickness, vec4&lt;float&gt; backgroundColor, vec4&lt;float&gt; headerColor, vec4&lt;float&gt; borderColor,<wbr> GUI_PanelLayout panelLayout = ON_WINDOW);
					</pre>
				</code>
				<p>O parâmetro <code>thickness</code> é a espessura da borda.</p>
				<p>Os parâmetros <var>backgroundColor, headerColor, borderColor</var> são como intuitivamente seus nomes definem - note que o canal alfa pode ser especificado.</p>
				<p>O parâmetro <var>panelLayout</var> é onde um objeto deve ser posicionado se for atribuído à outro objeto. Os tipos de layout são:</p> 
					<li>ON_WINDOW: O objeto terá sua posição e dimensão em relação a tela, mas manterá uma relação com um objeto pai - se for definido como filho.</li>
					<li>ON_HEADER: O objeto terá sua posição e dimensão relativas ao cabeçalho do objeto pai.</li>
					<li>ON_BODY: O objeto terá sua posição e dimensão relativas ao corpo do objeto pai.</li>
				<h4>Exemplo</h4>
				<code>
					<pre>
					Panel panel000(50.0f, 50.0f, 20.0f, 45.0f, 6.0f, vec4&lt;float&gt;(0.2f, 0.19f, 0.22f), vec4&lt;float&gt;(0.65f, 0.34f, 0.2f), vec4&lt;float&gt;(0.2f, 0.2f, 0.2f));
					</pre>
				</code>
				<p> O código anteriror cria o seguinte resultado:</p>
				<img src="media/img/panel000.png" class="img-ex"/>
				<p>A região com tom alaranjado é a área que denota o cabeçalho, enquanto a região  com tom cinza define o corpo do painel.</p>
				<h3>Texturas</h3>
				<p>Painéis podem receber uma imagem de fundo ao invés de apenas uma cor uniforme. Para isso deve-se instânciar um painel normalmente - defindo até mesmo sua cor uniforme(ela será ignorada se uma textura for fornecida) - e após bastas chamar a função <code>addTexture(std::string path, std::string uniformName, uint index)</code></p>
				<h4>Exemplo:</h4>
				<code>
					<pre>
					panel000.addTexture("../assets/textures/alpha/ranger.bmp", "img", 0);
					</pre>
				</code>
				<p>O código anterir cria o seguinte resultado:</p>
				<img src="media/img/panel000_img.png" class="img-ex"/>
				<p>Obs.: O nome uniforme sempre deve ser "img" seguido do indíce 0 ou então o sombreador irá assumir um comportamento indeterminado.</p>
				<p>Obs².: <code>addTexture</code> é uma função que pertence a classe base SRW, o que indica a dependência de GUI por SRW. Essa informação pode ser útil para flexibilizar as possibilidades de programação, mas painéis não foram projetados para usaram mas do que uma chamada de addTexture - se o fizer, a última chamada será válida - ou de qualquer outra função da classe SRW. Apesar de ser possível, não é legal.</p>
			</section>

			<section id="Checkbox">
				<h2>Checkbox</h2>
				<p>Checkbox são objetos úteis para sinalizar visualmente comportamentos binário, ora estão ativos ora estão desativados.</p>
				<p>Não existem muitas coisas especiais para um checkbox, a funcionalidade binária deve ser implementada arbitráriamente pelo programador seguindo o princípio de ativar/desativar na callback definada pela chamada à <var>setUserEvent</var>.</p>
				<h4>Exemplo:</h4>
				<code>
					<pre>
					Panel panel000(50.0f, 50.0f, 20.0f, 45.0f, 6.0f, vec4&lt;float&gt;(0.2f, 0.19f, 0.22f), vec4&lt;float&gt;(0.65f, 0.34f, 0.2f), vec4&lt;float&gt;(0.2f, 0.2f, 0.2f));
					Text title000("Humnst777.ttf", 18.0f, 50.0f, 50.0f, vec3&lt;float&gt;(0.9f), "Panel000", ON_HEADER);
					panel000.push(title000);
					Checkbox cbxPinPanel000(98.0f, 50.0f, ON_HEADER);
					cbxPinPanel000.setUserEvent([&](){
						cbxPinPanel000.setOn(!cbxPinPanel000.getOn());
						panel000.setPin(!panel000.getPin());
					});
					panel000.push(&cbxPinPanel000);
					</pre>
				</code>
				<p>O bloco de código anterior posicionará uma checkbox no cabeçalho de <var>panel000</var>. Ao marcar a checkbox, o painel ficará fixo em sua posição atual não podendo ser movido até que a checkbox seja desmarcada.</p>
				<img src="media/img/panel000_pin_checkbox.png" class="img-ex"/>
				<p>Checkbox podem ser usadas em conjunto assumindo uma relação semântica de ativação. Isso é útil para ter apenas uma opção de uma seção de opções ativa. Para isso é preciso definir um conjunto de checkbox como um grupo:</p>
				<code>
					<pre>
					Panel panel000(50.0f, 50.0f, 20.0f, 45.0f, 6.0f, vec4&lt;float&gt;(0.2f, 0.19f, 0.22f), vec4<float>(0.65f, 0.34f, 0.2f), vec4&lt;float&gt;(0.2f, 0.2f, 0.2f));
					panel000.addTexture("../assets/textures/alpha/ranger.bmp", "img", 0);
					Text title000("../assets/fonts/Humnst777.ttf", 18.0f, 50.0f, 50.0f, vec3&lt;float&gt;(0.9f), "PANEL000", ON_HEADER);
					Text txtTex0("../assets/fonts/Humnst777.ttf", 12.0f, 20.0f, 3.0f, vec3&lt;float&gt;(0.9f), "TEX0", ON_BODY);
					Text txtTex1("../assets/fonts/Humnst777.ttf", 12.0f, 92.0f, 3.0f, vec3&lt;float&gt;(0.9f), "TEX1", ON_BODY);
						
					Checkbox cbxPinPanel000(98.0f, 50.0f, ON_HEADER);
					Checkbox cbxTex0(10.0f, 2.0f, ON_BODY);
					Checkbox cbxTex1(80.0f, 2.0f, ON_BODY);

					Group groupTexOptions;
					groupTexOptions.checkbox.push_back(&cbxTex0);
					groupTexOptions.checkbox.push_back(&cbxTex1);

					title000.setUserEvent([&](){
						panel000.setHidden(true);
					});
					cbxPinPanel000.setUserEvent([&](){
						cbxPinPanel000.setOn(!cbxPinPanel000.getOn());
						panel000.setPin(!panel000.getPin());
					});
					cbxTex0.setUserEvent([&](){
						groupTexOptions.doUnique(cbxTex0.getID());
						cbxTex0.setOn(!cbxTex0.getOn());
						if(cbxTex0.getOn())
							panel000.addTexture("../assets/textures/brick_wall/yellow_bricks_diff_1k.jpg", "img", 0);
						else
							panel000.addTexture("../assets/textures/alpha/ranger.bmp", "img", 0);
					});
					cbxTex1.setUserEvent([&](){
						groupTexOptions.doUnique(cbxTex1.getID());
						cbxTex1.setOn(!cbxTex1.getOn());
						if(cbxTex1.getOn())
							panel000.addTexture("../assets/textures/brick_wall/yellow_bricks_nor_gl_2k.jpg", "img", 0);
						else
							panel000.addTexture("../assets/textures/alpha/ranger.bmp", "img", 0);
					});

					panel000.push(&cbxPinPanel000);
					panel000.push(&title000);
					panel000.push(&txtTex0);
					panel000.push(&txtTex1);
					panel000.push(&cbxTex0);
					panel000.push(&cbxTex1);
					</pre>
				</code>
				<p>O código anterior resultará nas seguintes imagens:</p>
				<img src="media/img/checkbox_group.png" class="img-ex"/>
				<p>Escolher entre "Tex0" e "Tex1" ou nenhum alternará a textura exibida no corpo do painel.</p>
				<p>A parte diferêncial nesse código é a instanciação do objeto <code>groupTexOption</code>. Uma vez que um objeto "Group" é criado, devemos atribuir os objetos checkbox desejados a pilha interna do grupo por meio do membro <code>checkbox</code>, e então dentro da callback de evento de cada checkbox chamar a função <code>doUnique</code> pertencente ao objeto do tipo Group passando o identificador do checkbox em questão como parâmetro. O que essa função faz é desinalizar todos os outros checkbox do grupo uma vez que o atualmente clicado esteja ativo.</p>
			</section>
            
			<section id="Dialog">
				<h2>Páginas de diálogo</h2>
				<p>Diálogos são comumentes usados em jogos de RPG. ImCreate implementa uma classe para a criação de elementos de diálogo de fácil utilização.</p>
				<p>A criação de um objeto Dialog é feito da seguinte maneira:</p>
				<code>
					<pre>
					Panel panel(50.0f, 50.0f, 80.0f, 20.0f, 2.0f, vec4<float>(1.0f), vec4<float>(0.3f), vec4<float>(1.0f), ON_WINDOW);
					Dialog dialog("Oldlondon.ttf", 24.0f, vec3<float>(1.0f), "Humnst777.ttf", 18.0f, vec3<float>(0.1f), "history.txt", &panel);
					dialog.flipPages("Capítulo I - Prelúdio");
					</pre>
				</code>
				<p>Objetos Dialog são projetados para funcionar como parte de um objeto Panel e portanto devem ter um painel devidamente configurado antes de qualquer operação com objeto Dialog.</p>
				<p>Para instânciar um objeto Panel verifique <a href="">aqui</a>. Painéis com escala de resolução várivel não são compativeis.</p>
				<p>Os parâmetros para instânciação de Dialog são:</p>
				<li>O nome de uma fonte para o título do painel de diálogo(espera-se que a fonte esteja no caminho assets/fonts).</li>
				<li>O tamanho da fonte para o título do painel de dialogo.</li>
				<li>A cor da fonte do título do painel de dialogo.</li>
				<li>O nome de uma fonte para o conteúdo no corpo do painel de diálogo(espera-se que a fonte esteja no caminho assets/fonts).</li>
				<li>O tamanho da fonte para o conteúdo dentro do corpo do painel de dialogo.</li>
				<li>A cor da fonte do conteúdo no corpo do painel de diálogo.</li>
				<li>Um arquivo de texto com o conteúdo do diálogo.</li>
				<li>O painel container do diálogo.</li>
				<p>A função membro flipPages(std::string) espera um ponto de entrada(normalmente o título de uma seção, capítulo...). Todo conteúdo dentro do arquivo de texto será lido até encontrar o caractere '-' e cada quebra de linha significa uma nova pagina de diálogo.</p>
				<p>Um arquivo de texto deve ser escrito da seguinte forma:</p>
				<code>
					<pre>
					Cápitulo I - Prólogo
					Descreve o começo de uma grande aventura...
					-
					Cápitulo I - Região concluída
					Parabéns, você está apto a seguir em frente.
					-
					</pre>
				</code>
				<p>Após '-', você pode inserir novos pontos de interrupção, para uma nova seção ou página de diálogo.</p>
				<p>Por meio da função keyboardEvent(SDL_Event* event) é possível controlar o avanço e recuo de páginas usando as teclas para direita/enter e para esquerda respectivamente.</p>
				<p>O aspecto visual de um objeto Dialog é pode ser visto <a href="media/img/dialog.png" target="_blank">aqui</a>.</p>
			</section>
        </section>
        <footer class="col-s-12 col-t-12 col-d-12">
        	<span class="col-s-12 col-t-12 col-d-2"><a href="index.html">Apresentação</a></span>
            <span class="col-s-12 col-t-12 col-d-12"><a href="tutoriais.html">Tutoriais</a></span>
            <span class="col-s-12 col-t-12 col-d-12"><a href="reference.html">Referência</a></span>
            <span class="col-s-12 col-t-12 col-d-12"><a href="https://github.com/renatopdmoura/pura-project.git" target="_blank">Download</a></span>
            <span id="copyright" class="col-s-12 col-t-12 col-d-12">&copy 2022 ImCreate</span>
        </footer>
       </main>
   </body>
</html>